/**
 * Couchbase Lite for .NET
 *
 * Original iOS version by Jens Alfke
 * Android Port by Marty Schoch, Traun Leyden
 * C# Port by Zack Gramana
 *
 * Copyright (c) 2012, 2013 Couchbase, Inc. All rights reserved.
 * Portions (c) 2013 Xamarin, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */

using System;
using System.IO;
using Apache.Http;
using Apache.Http.Client;
using Apache.Http.Client.Methods;
using Apache.Http.Client.Utils;
using Apache.Http.Conn;
using Apache.Http.Impl.Client;
using Apache.Http.Params;
using Apache.Http.Protocol;
using Apache.Http.Util;
using Org.Apache.Commons.Logging;
using Org.Apache.Http;
using Org.Apache.Http.Client.Methods;
using Sharpen;
using Sharpen.Reflect;

namespace Apache.Http.Impl.Client
{
	/// <summary>
	/// Base implementation of
	/// <see cref="Apache.Http.Client.HttpClient">Apache.Http.Client.HttpClient</see>
	/// that also implements
	/// <see cref="System.IDisposable">System.IDisposable</see>
	/// .
	/// </summary>
	/// <since>4.3</since>
	public abstract class CloseableHttpClient : HttpClient, IDisposable
	{
		private readonly Log log = LogFactory.GetLog(GetType());

		/// <exception cref="System.IO.IOException"></exception>
		/// <exception cref="Apache.Http.Client.ClientProtocolException"></exception>
		protected internal abstract CloseableHttpResponse DoExecute(HttpHost target, IHttpRequest
			 request, HttpContext context);

		/// <summary><inheritDoc></inheritDoc></summary>
		/// <exception cref="System.IO.IOException"></exception>
		/// <exception cref="Apache.Http.Client.ClientProtocolException"></exception>
		public virtual CloseableHttpResponse Execute(HttpHost target, IHttpRequest request
			, HttpContext context)
		{
			return DoExecute(target, request, context);
		}

		/// <summary><inheritDoc></inheritDoc></summary>
		/// <exception cref="System.IO.IOException"></exception>
		/// <exception cref="Apache.Http.Client.ClientProtocolException"></exception>
		public virtual CloseableHttpResponse Execute(IHttpUriRequest request, HttpContext
			 context)
		{
			Args.NotNull(request, "HTTP request");
			return DoExecute(DetermineTarget(request), request, context);
		}

		/// <exception cref="Apache.Http.Client.ClientProtocolException"></exception>
		private static HttpHost DetermineTarget(IHttpUriRequest request)
		{
			// A null target may be acceptable if there is a default target.
			// Otherwise, the null target is detected in the director.
			HttpHost target = null;
			URI requestURI = request.GetURI();
			if (requestURI.IsAbsolute())
			{
				target = URIUtils.ExtractHost(requestURI);
				if (target == null)
				{
					throw new ClientProtocolException("URI does not specify a valid host name: " + requestURI
						);
				}
			}
			return target;
		}

		/// <summary><inheritDoc></inheritDoc></summary>
		/// <exception cref="System.IO.IOException"></exception>
		/// <exception cref="Apache.Http.Client.ClientProtocolException"></exception>
		public virtual CloseableHttpResponse Execute(IHttpUriRequest request)
		{
			return Execute(request, (HttpContext)null);
		}

		/// <summary><inheritDoc></inheritDoc></summary>
		/// <exception cref="System.IO.IOException"></exception>
		/// <exception cref="Apache.Http.Client.ClientProtocolException"></exception>
		public virtual CloseableHttpResponse Execute(HttpHost target, IHttpRequest request
			)
		{
			return DoExecute(target, request, (HttpContext)null);
		}

		/// <summary>
		/// Executes a request using the default context and processes the
		/// response using the given response handler.
		/// </summary>
		/// <remarks>
		/// Executes a request using the default context and processes the
		/// response using the given response handler. The content entity associated
		/// with the response is fully consumed and the underlying connection is
		/// released back to the connection manager automatically in all cases
		/// relieving individual
		/// <see cref="Apache.Http.Client.ResponseHandler{T}">Apache.Http.Client.ResponseHandler&lt;T&gt;
		/// 	</see>
		/// s from having to manage
		/// resource deallocation internally.
		/// </remarks>
		/// <param name="request">the request to execute</param>
		/// <param name="responseHandler">the response handler</param>
		/// <returns>the response object as generated by the response handler.</returns>
		/// <exception cref="System.IO.IOException">in case of a problem or the connection was aborted
		/// 	</exception>
		/// <exception cref="Apache.Http.Client.ClientProtocolException">in case of an http protocol error
		/// 	</exception>
		public virtual T Execute<T, _T1>(IHttpUriRequest request, ResponseHandler<_T1> responseHandler
			) where _T1:T
		{
			return Execute(request, responseHandler, null);
		}

		/// <summary>
		/// Executes a request using the default context and processes the
		/// response using the given response handler.
		/// </summary>
		/// <remarks>
		/// Executes a request using the default context and processes the
		/// response using the given response handler. The content entity associated
		/// with the response is fully consumed and the underlying connection is
		/// released back to the connection manager automatically in all cases
		/// relieving individual
		/// <see cref="Apache.Http.Client.ResponseHandler{T}">Apache.Http.Client.ResponseHandler&lt;T&gt;
		/// 	</see>
		/// s from having to manage
		/// resource deallocation internally.
		/// </remarks>
		/// <param name="request">the request to execute</param>
		/// <param name="responseHandler">the response handler</param>
		/// <param name="context">
		/// the context to use for the execution, or
		/// <code>null</code> to use the default context
		/// </param>
		/// <returns>the response object as generated by the response handler.</returns>
		/// <exception cref="System.IO.IOException">in case of a problem or the connection was aborted
		/// 	</exception>
		/// <exception cref="Apache.Http.Client.ClientProtocolException">in case of an http protocol error
		/// 	</exception>
		public virtual T Execute<T, _T1>(IHttpUriRequest request, ResponseHandler<_T1> responseHandler
			, HttpContext context) where _T1:T
		{
			HttpHost target = DetermineTarget(request);
			return Execute(target, request, responseHandler, context);
		}

		/// <summary>
		/// Executes a request using the default context and processes the
		/// response using the given response handler.
		/// </summary>
		/// <remarks>
		/// Executes a request using the default context and processes the
		/// response using the given response handler. The content entity associated
		/// with the response is fully consumed and the underlying connection is
		/// released back to the connection manager automatically in all cases
		/// relieving individual
		/// <see cref="Apache.Http.Client.ResponseHandler{T}">Apache.Http.Client.ResponseHandler&lt;T&gt;
		/// 	</see>
		/// s from having to manage
		/// resource deallocation internally.
		/// </remarks>
		/// <param name="target">
		/// the target host for the request.
		/// Implementations may accept <code>null</code>
		/// if they can still determine a route, for example
		/// to a default target or by inspecting the request.
		/// </param>
		/// <param name="request">the request to execute</param>
		/// <param name="responseHandler">the response handler</param>
		/// <returns>the response object as generated by the response handler.</returns>
		/// <exception cref="System.IO.IOException">in case of a problem or the connection was aborted
		/// 	</exception>
		/// <exception cref="Apache.Http.Client.ClientProtocolException">in case of an http protocol error
		/// 	</exception>
		public virtual T Execute<T, _T1>(HttpHost target, IHttpRequest request, ResponseHandler
			<_T1> responseHandler) where _T1:T
		{
			return Execute(target, request, responseHandler, null);
		}

		/// <summary>
		/// Executes a request using the default context and processes the
		/// response using the given response handler.
		/// </summary>
		/// <remarks>
		/// Executes a request using the default context and processes the
		/// response using the given response handler. The content entity associated
		/// with the response is fully consumed and the underlying connection is
		/// released back to the connection manager automatically in all cases
		/// relieving individual
		/// <see cref="Apache.Http.Client.ResponseHandler{T}">Apache.Http.Client.ResponseHandler&lt;T&gt;
		/// 	</see>
		/// s from having to manage
		/// resource deallocation internally.
		/// </remarks>
		/// <param name="target">
		/// the target host for the request.
		/// Implementations may accept <code>null</code>
		/// if they can still determine a route, for example
		/// to a default target or by inspecting the request.
		/// </param>
		/// <param name="request">the request to execute</param>
		/// <param name="responseHandler">the response handler</param>
		/// <param name="context">
		/// the context to use for the execution, or
		/// <code>null</code> to use the default context
		/// </param>
		/// <returns>the response object as generated by the response handler.</returns>
		/// <exception cref="System.IO.IOException">in case of a problem or the connection was aborted
		/// 	</exception>
		/// <exception cref="Apache.Http.Client.ClientProtocolException">in case of an http protocol error
		/// 	</exception>
		public virtual T Execute<T, _T1>(HttpHost target, IHttpRequest request, ResponseHandler
			<_T1> responseHandler, HttpContext context) where _T1:T
		{
			Args.NotNull(responseHandler, "Response handler");
			HttpResponse response = Execute(target, request, context);
			T result;
			try
			{
				result = responseHandler.HandleResponse(response);
			}
			catch (Exception t)
			{
				HttpEntity entity = response.GetEntity();
				try
				{
					EntityUtils.Consume(entity);
				}
				catch (Exception t2)
				{
					// Log this exception. The original exception is more
					// important and will be thrown to the caller.
					this.log.Warn("Error consuming content after an exception.", t2);
				}
				if (t is RuntimeException)
				{
					throw (RuntimeException)t;
				}
				if (t is IOException)
				{
					throw (IOException)t;
				}
				throw new UndeclaredThrowableException(t);
			}
			// Handling the response was successful. Ensure that the content has
			// been fully consumed.
			HttpEntity entity_1 = response.GetEntity();
			EntityUtils.Consume(entity_1);
			return result;
		}

		public abstract ClientConnectionManager GetConnectionManager();

		public abstract HttpParams GetParams();

		public abstract void Close();
	}
}
